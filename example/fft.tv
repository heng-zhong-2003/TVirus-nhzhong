let modAdd = \a, b . ((a + b) % 998244353)

let modSub = \a, b . ((a - b + 998244353) % 998244353)

let modMul = \a, b . ((a * b) % 998244353)

let qkpow = \x, k . 
  if k == 0 {
    1
  } else {
    modMul(qkpow(x * x, k / 2), (
      if k % 2 == 1 { x } else { 1 }
    ))
  }

let inv = \x . qkpow(x, 998244353 - 2)

let modDiv = \a, b . modMul(a, inv(b))


data SubVector = MkSubVector(Vector, Int, Int)

let toSub = \t . MkSubVector(t, 1, 0)

let fromSub = \s . match s with
| MkSubVector(v, a, b) -> v

let getEven = \t . match t with
| MkSubVector(v, a, b) -> MkSubVector(v, 2 * a, 2 * b)

let getOdd = \t . match t with
| MkSubVector(v, a, b) -> MkSubVector(v, 2 * a, 2 * b + 1)

let subAccess = \t, x . match t with
| MkSubVector(v, a, b) -> vec_access(v, a * x + b)

let DFT = \v, n, rev . 
  if n == 1 {
    v
  } else {
    let g = DFT(getEven(v), n / 2, rev),
        h = DFT(getOdd(v), n / 2, rev),
        gi = if rev { inv(3) } else { 3 },
        gn = qkpow(gi, (998244353 - 1) / n)
    in toSub(vec_build(\k . (
      if k < (n / 2) {
        modAdd(subAccess(g, k), modMul(qkpow(gn, k), subAccess(h, k)))
      } else {
        modSub(subAccess(g, k), modMul(qkpow(gn, k), subAccess(h, k)))
      })
    , n))
  }

let toNum = \v . match v with
| Empty() -> 0
| Leaf(x) -> x
| Branch(_, v1, v2, v3, v4) -> 
  let combNum = (\r, v .
    let ln = vec_length(v)
    in modAdd(modMul(r, qkpow(10, ln)), toNum(v))
  ) in
  combNum(combNum(combNum(combNum(0, v4), v3), v2), v1)

let main = 
  let v1 = vec_build(\i . (4 - i), 4) in
  let v2 = vec_build(\i . (i * 2), 4) in
  let fv1 = fromSub(DFT(toSub(v1), 4, False)) in
  let fv2 = fromSub(DFT(toSub(v2), 4, False)) in
  let fresult = vec_resize(vec_zipWith(fv1, fv2, modMul), 8) in
  let result = fromSub(DFT(toSub(fresult), 8, True))
  in toNum(result)
